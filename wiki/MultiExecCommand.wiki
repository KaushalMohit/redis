#sidebar GenericCommandsSidebar

= MULTI =
= COMMAND1 ... =
= COMMAND2 ... =
= COMMANDN ... =
= EXEC or DISCARD =

 MULTI, EXEC and DISCARD commands are the fundation of Redis Transactions.
 A Redis Transaction allows to execute a group of Redis commands in a single
 step, with two important guarantees:

* All the commands in a transaction are serialized and executed sequentially. It can never happen that a request issued by another client is served *in the middle* if the execution of a Redis transaction. This guarantees that the commands are executed as a single atomic operation.
* Either all of the commands or none are processed. The EXEC command triggers the execution of all the commands in the transaction, so if a client lose the connection to the server in the context of a transaction before calling the MULTI command none of the operations are performed, instead if the MULTI command is called, all the operations are performed. An exception to this rule is when the Append Only File is enabled: every command that is part of a Redis transaction will log in the AOF as long as the operation is completed, so if the Redis server crashes or is killed by the system administrator in some hard way it is possible that only a partial number of operations are registered.

== Usage ==

 A Redis transaction is entered using the MULTI command. The command always
 replies with OK. At this point the user can issue multiple commands. Instead
 to execute this commands Redis will "queue" them. All the commands are
 executed once EXEC is called.

 Calling DISCARD instead will flush the transaction queue and will exit
 the transaction.

 The following is an example using the Ruby client:
{{{
?> r.multi
=> "OK"
>> r.incr "foo"
=> "QUEUED"
>> r.incr "bar"
=> "QUEUED"
>> r.incr "bar"
=> "QUEUED"
>> r.exec
=> [1, 1, 2]
}}}
 As it is possible to see from the session above, MULTI returns an "array" of
 replies, where every element is the reply of a single command in the
 transaction, in the same order the commands were queued.

 When a Redis connection is in the context of a MULTI request, all the commands
 will reply with a simple string "QUEUED" if they are correct from the
 point of view of the syntax and arity (number of arguments) of the commaand.
 Some command is still allowed to fail during execution time.

 This is more clear if at protocol level: in the following example one command
 will fail when executed even if the syntax is right:
{{{
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
MULTI
+OK
SET a 3 
abc
+QUEUED
LPOP a
+QUEUED
EXEC
*2
+OK
-ERR Operation against a key holding the wrong kind of value
}}}
 MULTI returned a two elements bulk reply in witch one of this is a +OK
 code and one is a -ERR reply. It's up to the client lib to find a sensible
 way to provide the error to the user.

 IMPORTANT: even when a command will raise an error, all the other commands
 in the queue will be processed. Redis will NOT stop the processing of
 commands once an error is found.

 Another example, again using the write protocol with telnet, shows how
 syntax errors are reported ASAP instead:
{{{
MULTI
+OK
INCR a b c
-ERR wrong number of arguments for 'incr' command
}}}
 This time due to the syntax error the "bad" INCR command is not queued
 at all.

== The DISCARD command ==

 DISCARD can be used in order to abort a transaction. No command will be
 executed, and the state of the client is again the normal one, outside
 of a transaction. Example using the Ruby client:
{{{
?> r.set("foo",1)
=> true
>> r.multi
=> "OK"
>> r.incr("foo")
=> "QUEUED"
>> r.discard
=> "OK"
>> r.get("foo")
=> "1"
}}}

== Return value ==

[ReplyTypes Multi bulk reply], specifically:

{{{
The result of a MULTI/EXEC command is a multi bulk reply where every element is the return value of every command in the atomic transaction.
}}}
